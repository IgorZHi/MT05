# Архитектура


***Архитектура веб-приложения*** - представляет отношения и взаимодействия между такими компонентами, как пользовательские интерфейсы, мониторы обработки транзакций, базы данных.
Все приложения состоят из двух частей - клиентской (front-end) и серверной (back-end).


#### Какие существуют уровни веб-приложения?

Существует четыре общих уровня веб-приложений:

Уровень представления (PL)
Уровень обслуживания данных (DSL)
Уровень бизнес-логики (BLL)
Уровень доступа к данным (DAL)



#### За что отвечает каждый из них?

***Уровень представления***
PL отображает пользовательский интерфейс и упрощает взаимодействие с пользователем. Уровень представления имеет компоненты пользовательского интерфейса, которые визуализируют и показывают данные для пользователей. Также существуют компоненты пользовательского процесса, которые задают взаимодействие с пользователем. PL предоставляет всю необходимую информацию клиентской стороне. Основная цель уровня представления - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.


***Уровень службы данных***
DSL передает данные, обработанные уровнем бизнес-логики, на уровень представления. Этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента.


***Слой бизнес-логики***
BLL несет ответственность за надлежащий обмен данными. Этот уровень определяет логику бизнес-операций и правил. Вход на сайт - это пример уровня бизнес-логики.


***Уровень доступа к данным***
DAL предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD - создание, чтение, обновление, удаление.



#### Что такое монолитная и микросервисная архитектуры веб-приложения?

***Традиционная монолитная архитектура веб-приложения*** состоит из трех частей - базы данных, клиентской и серверной сторон. Это означает, что внутренняя и внешняя логика, как и другие фоновые задачи, генерируются в одной кодовой базе. 
***Архитектура микросервисов*** -  этот подход позволяет разработчикам создавать веб-приложение из набора небольших сервисов.


#### Каковы различия между монолитом и микросервисами?


***В монолитной архитектуре*** -  чтобы изменить или обновить компонент приложения, разработчики программного обеспечения должны переписать все приложение.
***В архитектуре микросервисов*** - разработчики создают и развертывают каждый компонент отдельно.


#### Почему не все приложения построены на микросервисной архитектуре?

 ***Монолитные приложения*** разрабатываются быстрее, считаются более безопасными, но их трудно обновлять и масштабировать. Поэтому монолит рекомендуется применять в небольших приложениях, которые нетрудно будет обслуживать.

 ***Архитектура микросервисов*** выгодна для больших и сложных проектов, поскольку каждый сервис может быть изменен без ущерба для других блоков. Поэтому, если вам нужно обновить логику оплаты, вам не придется на время останавливать работу сайта. 


#### Каковы особенности тестирования монолитных и микросервисных веб-приложений?

***Тестирование монолитных веб-приложений***
При тестировании таких приложений важно, чтобы обновления при запросах происходили корректно. Для этого тестируют:

Корректную первоначальную загрузку всех блоков

Обновление только тех блоков, в которых меняется информация

Обновление данных в связанных блоках. Например, обновление счетчика непрочитанных писем при открытии письма

Обработка некорректных запросов или при отсутствии интернета

***Тестирование микросервисов*** - так как это множество модулей где каждый из них обслуживает одну бизнес-задачу.
Поэтому тестирование состоит из определенных типов :

unit-тестирование;
контрактное тестирование;
интеграционное тестирование;
end-to-end тестирование;
нагрузочное тестирование;
UI- или функциональное тестирование.

Теперь рассмотрим подробнее все виды тестирования.

Unit-тестирование
Unit-тестирование (модульное тестирование) — это вид тестирования ПО, позволяющий проверить корректность отдельных модулей или компонентов программного обеспечения. Цель: проверка того, что каждая единица программного кода работает корректно.

Unit-тестирование бывает двух видов:

позитивное (проверить поведение методов в нормальных условиях);
негативное (проверить устойчивость системы к нештатным ситуациям).

Контрактное тестирование
 работают над микросервисами несколько команд:

бэкенд;
фронтенд;
тестировщики.
 Для этого, используется контракт между командами, который называется Pact. Он содержит в себе все методы и возвраты всех сервисов.

Контрактное тестирование подразумевает отношение к микросервису, как к черному ящику. Оно нацелено на то, чтобы мы могли убедиться, что все работает так как надо. Если одна из схем работает не по пакту, это считается дефектом.

Интеграционное тестирование
Во время интеграционного тестирования проверяется, насколько корректно разные микросервисы взаимодействуют друг с другом. Этот вид тестирования считается самым критичным тестом всей архитектуры. При положительном исходе тестирования мы можем быть уверены, что она спроектирована правильно, и все независимые микросервисы работают как единое целое в соответствии с ожиданиями.

End-to-end тестирование
E2E тестирует бизнес-логику подобно процессу тестирования в интеграционном, но уже не изолированно, а в масштабе всей системы.

В end-to-end тестировании проверяется, как взаимодействуют все сервисы c платформой:

регистрация;
авторизация; 
игровая деятельность; 
пополнение и снятие денежных средств.
То есть мы проверяем насколько соответствует все приложение запросам заказчика. 

Нагрузочное тестирование
Процесс нагрузочного тестирования формально делится на 4 этапа:

тестирование производительности (Performance Testing);
тестирование стабильности или надежности;
стресс-тестирование;
объемное тестирование (Volume Testing).
Для тестирования, мы используем JMeter, а сами нагрузочные скрипты написаны на Groovy.

UI- или функциональное тестирование
Это итоговый вид тестирования. Мы тестируем практически все то же самое, что и при end-to-end тестировании, но только с использованием UI. Мы проводим UI тестирование мануально и также делаем автотесты.